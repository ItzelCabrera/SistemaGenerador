# -*- coding: utf-8 -*-
"""practica 1_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UnaR1-0Rd5tp8X24WTzDjSvtcV0BYPfZ
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm

def trapezoidal_cutted(x,a,b,c,d):
  X = np.zeros(len(x))
  for i in range (len(x)):
    if x[i] <= a:
      X[i] = 1
    if x[i] > a and x[i] <= b:
      X[i] = (x[i]-a)/(b-a)
    if x[i] > b and x[i] <= c:
      X[i] = 1
    if x[i] > c and x[i] <= d:
      X[i] = (d-x[i])/(d-c)
    if x[i] > d:
      X[i] = 0
  return X

def trapezoidal_complete(x,a,b,c,d):
  X = np.zeros(len(x))
  for i in range (len(x)):
    if x[i] <= a:
      X[i] = 0
    if x[i] > a and x[i] <= b:
      X[i] = (x[i]-a)/(b-a)
    if x[i] > b and x[i] <= c:
      X[i] = 1
    if x[i] > c and x[i] <= d:
      X[i] = (d-x[i])/(d-c)
    if x[i] > d:
      X[i] = 0
  return X

#universos de entrada
pos_v = np.arange(0,359.5,1) #pos de la veleta
pos_g = np.arange(0,359.5,1) #pos del generador
X, Y = np.meshgrid(pos_v, pos_g)
#univeros de salida
vel_g = np.arange(0,600.5,0.5) #velocidad del generador
sentido_g = np.arange(0,2.001,0.001) #sentido de giro del generador
#conjuntos del universo de entrada pos_generador
norte_EG = trapezoidal_cutted(pos_g,0,0,40,80)
este_G = trapezoidal_complete(pos_g,40,80,120,160)
sur_G = trapezoidal_complete(pos_g,120,160,200,240)
oeste_G = trapezoidal_complete(pos_g,200,240,280,320)
norte_OG = trapezoidal_complete(pos_g,280,320,359,359)
#conjuntos del universo de entrada pos_veleta
norte_EV = trapezoidal_cutted(pos_v,0,0,40,80)
este_V = trapezoidal_complete(pos_v,40,80,120,160)
sur_V = trapezoidal_complete(pos_v,120,160,200,240)
oeste_V = trapezoidal_complete(pos_v,200,240,280,320)
norte_OV = trapezoidal_complete(pos_v,280,320,359,359)
#conjuntos del universo de salida velocidad
baja = trapezoidal_cutted(vel_g,0,0,120,240)
media = trapezoidal_complete(vel_g,120,240,360,480)
alta = trapezoidal_complete(vel_g,360,480,600,600)
Cvel = np.zeros((len(pos_g),len(pos_v)))
#conjuntos del universo de salida sentido de giro
ah = trapezoidal_cutted(sentido_g,0,0,0.5,1) #sentido antihorario
nm = trapezoidal_complete(sentido_g,0.75,0.875,1.125,1.25) #no mover
h = trapezoidal_complete(sentido_g,1,1.5,2,2) #senido horario
Csentido = np.zeros((len(pos_g),len(pos_v)))

plt.figure()
plt.plot(pos_g,norte_EG,label = 'Norte EG')
plt.plot(pos_g,este_G,label = 'Este EG')
plt.plot(pos_g,sur_G,label = 'Sur EG')
plt.plot(pos_g,oeste_G,label = 'Oeste EG')
plt.plot(pos_g,norte_OG,label = 'Norte OG')
plt.xlabel('pos_generador')
plt.ylabel('miu')
plt.title("conjuntos de entrada del universo pos_generador")
plt.legend ()

plt.figure()
plt.plot(pos_v,norte_EV,label = 'Norte EV')
plt.plot(pos_v,este_V,label = 'Este EV')
plt.plot(pos_v,sur_V,label = 'Sur EV')
plt.plot(pos_v,oeste_V,label = 'Oeste EV')
plt.plot(pos_v,norte_OV,label = 'Norte OV')
plt.xlabel('pos_veleta')
plt.ylabel('miu')
plt.title("conjuntos de entrada del universo pos_veleta")
plt.legend ()

plt.figure()
plt.plot(vel_g,baja,label = 'Baja')
plt.plot(vel_g,media,label = 'Media')
plt.plot(vel_g,alta,label = 'Alta')
plt.xlabel('velocidad [Hz]')
plt.ylabel('miu')
plt.title("conjuntos de salida del universo velocidad")
plt.legend ()

plt.figure()
plt.plot(sentido_g,ah,label = 'Antihorario')
plt.plot(sentido_g,nm,label = 'No mover')
plt.plot(sentido_g,h,label = 'Horario')
plt.xlabel('sentido de giro')
plt.ylabel('miu')
plt.title("conjuntos de salida del universo sentido de giro")
plt.legend ()

miu_norteEG_posG = np.zeros(len(pos_g))
miu_esteG_posG = np.zeros(len(pos_g))
miu_surG_posG = np.zeros(len(pos_g))
miu_oesteG_posG = np.zeros(len(pos_g))
miu_norteOG_posG = np.zeros(len(pos_g))
miu_norteEV_posV = np.zeros(len(pos_v))
miu_esteV_posV = np.zeros(len(pos_v))
miu_surV_posV = np.zeros(len(pos_v))
miu_oesteV_posV = np.zeros(len(pos_v))
miu_norteOV_posV = np.zeros(len(pos_v))

agreg_baja = np.zeros(len(vel_g))
agreg_media = np.zeros(len(vel_g))
agreg_alta = np.zeros(len(vel_g))

agreg_ah= np.zeros(len(vel_g)) #sentido antihorario
agreg_nm = np.zeros(len(vel_g)) #no mover
agreg_h = np.zeros(len(vel_g)) #sentido horario

for i in range (len(pos_g)):
    #difusificación: obtienen la membresía
    miu_norteEG_posG[i] = norte_EG[i]
    miu_esteG_posG[i] = este_G[i]
    miu_surG_posG[i] = sur_G[i]
    miu_oesteG_posG[i] = oeste_G[i]
    miu_norteOG_posG[i] = norte_OG[i]
    miu_norteEV_posV[i] = norte_EV[i]
    miu_esteV_posV[i] = este_V[i]
    miu_surV_posV[i] = sur_V[i]
    miu_oesteV_posV[i] = oeste_V[i]
    miu_norteOV_posV[i] = norte_OV[i]

for x_ in range (len(pos_v)):
  for y_ in range (len(pos_g)):
    #evaluación de reglas con composición max-min para la velocidad [Hz]
    agreg_baja = np.max([np.min([miu_norteEV_posV[x_] ,miu_norteEG_posG[y_]]),
                         np.min([miu_norteEV_posV[x_] ,miu_norteOG_posG[y_]]),
                         np.min([miu_esteV_posV[x_] ,miu_esteG_posG[y_]]),
                         np.min([miu_surV_posV[x_] ,miu_surG_posG[y_]]),
                         np.min([miu_oesteV_posV[x_] ,miu_oesteG_posG[y_]]),
                         np.min([miu_norteOV_posV[x_] ,miu_norteEG_posG[y_]]),
                         np.min([miu_norteOV_posV[x_] ,miu_norteOG_posG[y_]])
                         ])
    agreg_media = np.max([np.min([miu_norteEV_posV[x_] ,miu_esteG_posG[y_]]),
                         np.min([miu_norteEV_posV[x_] ,miu_oesteG_posG[y_]]),
                         np.min([miu_esteV_posV[x_] ,miu_norteEG_posG[y_]]),
                         np.min([miu_esteV_posV[x_] ,miu_surG_posG[y_]]),
                         np.min([miu_esteV_posV[x_] ,miu_norteOG_posG[y_]]),
                         np.min([miu_surV_posV[x_] ,miu_esteG_posG[y_]]),
                         np.min([miu_surV_posV[x_] ,miu_oesteG_posG[y_]]),
                         np.min([miu_oesteV_posV[x_] ,miu_norteEG_posG[y_]]),
                         np.min([miu_oesteV_posV[x_] ,miu_surG_posG[y_]]),
                         np.min([miu_oesteV_posV[x_] ,miu_norteOG_posG[y_]]),
                         np.min([miu_norteOV_posV[x_] ,miu_esteG_posG[y_]]),
                         np.min([miu_norteOV_posV[x_] ,miu_oesteG_posG[y_]])
                         ])
    agreg_alta = np.max([np.min([miu_norteEV_posV[x_] ,miu_surG_posG[y_]]),
                        np.min([miu_esteV_posV[x_] ,miu_oesteG_posG[y_]]),
                        np.min([miu_surV_posV[x_] ,miu_norteEG_posG[y_]]),
                        np.min([miu_surV_posV[x_] ,miu_norteOG_posG[y_]]),
                        np.min([miu_oesteV_posV[x_] ,miu_esteG_posG[y_]]),
                        np.min([miu_norteOV_posV[x_] ,miu_surG_posG[y_]])
                         ])
    #evaluación de reglas con composición max-min para el sentido
    agreg_ah= np.max([np.min([miu_norteEV_posV[x_] ,miu_esteG_posG[y_]]),
                        np.min([miu_norteEV_posV[x_] ,miu_surG_posG[y_]]),
                        np.min([miu_esteV_posV[x_] ,miu_surG_posG[y_]]),
                        np.min([miu_surV_posV[x_] ,miu_oesteG_posG[y_]]),
                        np.min([miu_surV_posV[x_] ,miu_norteOG_posG[y_]]),
                        np.min([miu_oesteV_posV[x_] ,miu_norteEG_posG[y_]]),
                        np.min([miu_oesteV_posV[x_] ,miu_esteG_posG[y_]]),
                        np.min([miu_oesteV_posV[x_] ,miu_norteOG_posG[y_]]),
                        np.min([miu_norteOV_posV[x_] ,miu_esteG_posG[y_]])
                      ])
    agreg_nm = np.max([np.min([miu_norteEV_posV[x_] ,miu_norteEG_posG[y_]]),
                        np.min([miu_norteEV_posV[x_] ,miu_norteOG_posG[y_]]),
                        np.min([miu_esteV_posV[x_] ,miu_esteG_posG[y_]]),
                        np.min([miu_surV_posV[x_] ,miu_surG_posG[y_]]),
                        np.min([miu_oesteV_posV[x_] ,miu_oesteG_posG[y_]]),
                        np.min([miu_norteOV_posV[x_] ,miu_norteEG_posG[y_]]),
                        np.min([miu_norteOV_posV[x_] ,miu_norteOG_posG[y_]])
                         ])
    agreg_h = np.max([np.min([miu_norteEV_posV[x_] ,miu_oesteG_posG[y_]]),
                        np.min([miu_esteV_posV[x_] ,miu_norteEG_posG[y_]]),
                        np.min([miu_esteV_posV[x_] ,miu_oesteG_posG[y_]]),
                        np.min([miu_esteV_posV[x_] ,miu_norteOG_posG[y_]]),
                        np.min([miu_surV_posV[x_] ,miu_norteEG_posG[y_]]),
                        np.min([miu_surV_posV[x_] ,miu_esteG_posG[y_]]),
                        np.min([miu_oesteV_posV[x_] ,miu_surG_posG[y_]]),
                        np.min([miu_norteOV_posV[x_] ,miu_surG_posG[y_]]),
                        np.min([miu_norteOV_posV[x_] ,miu_oesteG_posG[y_]])
                         ])

    #desdifusificador: obtienen los cortes de alta, media y baja
    baja_cut = np.minimum(agreg_baja*np.ones(len(baja)),baja)
    media_cut = np.minimum(agreg_media*np.ones(len(media)),media)
    alta_cut = np.minimum(agreg_alta*np.ones(len(alta)),alta)
    #desdifusificador: obtienen los cortes de antihorario, no mover, horario
    ah_cut = np.minimum(agreg_ah*np.ones(len(ah)),ah)
    nm_cut = np.minimum(agreg_nm*np.ones(len(nm)),nm)
    h_cut = np.minimum(agreg_h*np.ones(len(h)),h)
    #desdifusificador:obtiene la unión de los cortes de baja, media y alta
    CT_vel = np.maximum(baja_cut,np.maximum(media_cut,alta_cut))
    CT_sentido = np.maximum(ah_cut,np.maximum(nm_cut,h_cut))
    #desdifusificador:método de centroide del área
    aux1 = 0
    aux2 = 0
    aux3 = 0
    aux4 = 0
    for i in range(len(vel_g)):
        aux1 += CT_vel[i]*i #salto de 1
        aux2 += CT_vel[i]
        aux3 += CT_sentido[i]*i #salto de 1
        aux4 += CT_sentido[i]
    zd_1 = aux1/aux2
    zd_2 = aux3/aux4
    Cvel[x_][y_] = zd_1
    Csentido[x_][y_] = zd_2

plt.figure()
plt.plot(vel_g, baja_cut,label = "corte baja")
plt.plot(vel_g, media_cut,label = "corte media")
plt.plot(vel_g, alta_cut,label = "corte alta")

plt.figure()
plt.plot(sentido_g, ah_cut,label = "corte antihorario")
plt.plot(sentido_g, nm_cut,label = "corte no mover")
plt.plot(sentido_g, h_cut,label = "corte horario")

fig2, ax2 = plt.subplots(subplot_kw={"projection": "3d"})
surf = ax2.plot_surface(X, Y, Cvel, cmap=cm.coolwarm,
                       linewidth=0, antialiased=False)

fig3, ax3 = plt.subplots(subplot_kw={"projection": "3d"})
surf2 = ax3.plot_surface(X, Y, Csentido, cmap=cm.coolwarm,
                       linewidth=0, antialiased=False)